
# KMP

### 1.KMP概念

* KMP主要用在字符串匹配上。主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。

### 2.前缀表

* next数组就是一个前缀表。用来回溯的，它记录了模式串与主串不匹配的时候，模式串应该从哪开始重新匹配。任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，也意味着在某个字符失配时，前缀表告诉下一步匹配中，模式串应该跳到哪个位置。

* 前缀表里的数统一减一，开始位置设置为-1，形成新前缀表（next数组），避免了死循环，只不过后续读取前缀表里的数值的时候，要加一，才是我们想要的值。

前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。

后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。

#### next数组计算

![image.png](attachment:7d3839c1-72c8-4678-bb79-4a2e28647970.png)

#### 前缀表统一减一


```python
def getnext(next, s):
    j = -1
    next[0] = j
    for i in range(1, len(s)):
        while j >= 0 and s[i] != s[j + 1]:   # 前后缀不同
            j = next[j]   # 向前回溯
        if s[i] == s[j + 1]:   # 相同前后缀
            j += 1
        next[i] = j
```

#### 前缀表不减一


```python
def getnext(next, s):
    j = 0
    next[0] = j
    for i in range(1, len(s)):
        while j > 0 and s[i] != s[j]:
            j = next[j - 1]
        if s[i] == s[j]:
            j += 1
        next[i] = j
```

### 3.时间复杂度分析

* 文本串长度为n，模式串长度为m，匹配过程是$O(n)$，生成next数组时间复杂度是$O(m)$，所以KMP时间复杂度是$O(m+n)$。
