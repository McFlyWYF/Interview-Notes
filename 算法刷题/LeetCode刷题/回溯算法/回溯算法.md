
# 回溯算法

* 就是常说的DFS算法，本质上是一种暴力穷举算法。解决一个回溯问题，实际上就是一个决策树的遍历过程.

#### 1. 回溯法解决的问题

  * 组合问题：N个数里面按一定规则找出k个数的集合。（不强调元素顺序，无序）（需要start）
  * 排列问题：N个数按一定规则全排列，有几种排列方式。（强调元素顺序，有序）（不需要start）
  * 切割问题：一个字符串按一定规则有几种切割方式。
  * 子集问题：一个N个数的集合里有多少符合条件的子集。（需要start）
  * 棋盘问题：N皇后，解数独等。

* **回溯法**采用试错的思想，尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至上几步的计算，再通过其他的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
  * 找到一个可能存在的正确答案；
  * 在尝试了所有可能的分步方法后宣告该问题没有答案；
* 回溯法的终止条件就是搜索到叶子节点后，就到达终止条件了。

```python
if 终止条件:
    存放结果
    return
```

#### 2.回溯搜索的遍历过程

![56220478B4CF2168E4AC4EF99F3CCAF1.png](attachment:eba17f29-d07a-4a95-9ec4-e52164173aad.png)

* 剪枝的精髓：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没必要搜索了。

#### 3.回溯函数遍历过程伪代码

```python
for 选择：本层集合中的元素（树中节点孩子的数量就是集合的大小）:
    处理节点
    backtrack（路径，选择列表）. # 递归
    回溯，撤销处理结果
```

#### 4.回溯算法模版框架

```python
result = []
def abcktrack(路径，选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        # 做选择
        路径.add(选择)
        backtrack(路径，选择列表)
        # 撤销选择
        路径.remove(选择)
```

* **深度优先搜索算法**是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当结点`v`的所在边都已被探寻过，搜索将回溯到发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。
* 与动态规划的区别
  * （共同点）用于求解多阶段决策问题，即：
    * 求解一个问题分为很多步骤（阶段）；
    * 每一个步骤（阶段）可以有多种选择；
  * （不同点）
    * 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。适合应用于评估一个方案的效果。

#### 题目

* 组合问题

  * 77. 组合（已完成）
  * 77. 组合`(剪枝)`（已完成）
  * 216.组合总和`(3)`（已完成）
  * 17. 电话号码的字母组合（已完成）
  * 39. 组合总和`(1)`（已完成）
  * 40. 组合总和`(2)`（已完成）

* 分割问题

  * 131.分割回文串（已完成）
  * 93. 复原IP地址（已完成）

* 子集问题

  * 78. 子集`(1)`（已完成）
  * 90. 子集`(2)`（已完成）
  * 698.划分为k个相等的子集(已完成)

* 排列问题

  * 46. 全排列`(1)`（已完成）
  * 47. 全排列`(2)`（已完成）

* 棋盘问题

  * 51. N皇后(已完成)
  * 37. 解数独

* 其他

  * 419.递增子序列
  * 332.重新安排行程

### 时间复杂度分析

##### 子集问题分析

* 时间复杂度：$O(n * 2^n)$
    * 因为每一个元素的状态有取和不取两种，所以时间复杂度为$O(2^n)$，构造每一组自己都需要填进数组，又需要$O(n)$。

* 空间复杂度：$O(n)$
    * 递归深度为n，所用栈空间为$O(n)$，每一层递归所用的空间都是常数级别。

##### 排列问题分析

* 时间复杂度：$O(n!)$
    * 每一层节点为$n$，第二层每一个分支都延伸了$n-1$个分支，再往下又是$n-2$个分支，所以一直到叶子节点就是$n * n - 1 * n - 2 * ... * 1 = n!$

* 空间复杂度：$O(n)$

##### 组合问题分析

* 时间复杂度：$O(n * 2 ^ n)$
    * 组合问题就是一种子集的问题，所以组合问题最坏的情况下，也不超过子集问题的时间复杂度。

* 空间复杂度：$O(n)$

##### N皇后问题

* 时间复杂度：$O(n!$
* 空间复杂度：$O(n)$

##### 解数独问题

* 时间复杂度：$O(9^m)$，$m$是'.'的数目。
* 空间复杂度：$O(n^2)$，递归深度。

### 解题思路

#### 组合问题

* 需要start

* 剪枝：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够体面要求的k个元素了，就没必要搜索了。

##### 组合总和

* 需要start

* 剪枝：已选元素总和如果已经大于n了，就没必要再遍历了。`i <= 9 - (k - len(path)) + 1`

* 集合元素重复时的剪枝：
    * 同一树支：`if nums[i] == nums[i - 1] and used[i - 1] = True`
    * 同一树层：`if nums[i] == nums[i - 1] and used[i - 1] = False`

#### 切割问题

#### 排列问题

* 不需要start
