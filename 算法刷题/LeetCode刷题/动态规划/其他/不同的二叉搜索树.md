
# 不同的二叉搜索树

### 给定一个正整数n，求以1...n为节点组成的二叉搜索树有多少种？

* 例如：
    * 输入：3
    * 输出：5

* 例如dp[3]：
    * 元素1为头节点搜索树的数量+元素2为头节点搜索树的数量+元素3位头节点搜索树的数量
        * 元素1为头节点搜索树的数量=右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量 = dp[2] + dp[0]
        * 元素2为头节点搜索树的数量=右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量 = dp[1] + dp[1]
        * 元素3为头节点搜索树的数量=右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量 = dp[0] + dp[2]

* 假设n个节点存在二叉排序树的个数是$G(n)$，令$f(i)$是以i为根的二叉搜索树的个数，则$G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)$
* 当i为根节点时，其左子树节点个数为$i - 1$个，右子树节点为$n - i$，则$f(i) = G(i - 1) * G(n - i)$
* 综合得$G(n) = G(0) * G(n - 1) + ... + G(n - 1) * G(0)$

* 确定dp数组
    * dp[i]：1到i为节点组成的二叉搜索树的个数
* 确定递推公式
    * dp[i] += dp[以j为头节点左子树节点数量] * dp[以j为头节点右子树节点数量]
    * `dp[i] += dp[j - 1] * dp[i - j]`


```python
def solve(n):
    dp = [0 for _ in range(n + 1)]
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(1, i + 1):
            dp[i] += dp[j - 1] * dp[i - j]
    print(dp)
    return dp[n]
```


```python
n = 3
solve(n)
```

    [1, 1, 2, 5]
    




    5



* 时间复杂度：$O(n^2)$
* 空间复杂度：$O(n)$
